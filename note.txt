app.zeplin.com
kerry22020@163.com


            
https://vnloto.365ball.me/#/



获取有效彩种数据， 不同彩种在哪展示？
查询正在投注，可以投注的数据

少了查询玩家用户名等字段信息


后台管理：
  1，http://159.138.98.56/login?redirect=%2Findex
  2，http://119.12.169.122/login?redirect=%2Findex




https://ctpwebs1.yuu1f.com/lottery/168


web.001122.co
h5.001122.co

正式pc：
   http://www.365ball.one/

律：
  工作，心无旁骛




龙回头战法
  关键支撑位或重要均线附近
  股价是否企稳和重要支撑位的判断

1，套牢筹码有没有出逃
2，底部获利筹码有没有获利了结
3，低位筹码不套现，表示行情能延续
4，主力行为--股价长期上涨，底部获利筹码会发生沉淀且持续的时间较长
5，散户行为--股价长期下跌，顶部被套筹码会发生沉淀，持续的时间不长

低位单峰密集+放量上涨，这才是行情启动真信号
缩量越多，持续时间越长，筑底可能性越大
低位没有筹码的个股，一旦开始下跌之后，下方是没有支撑的
当股价开始向上突破单峰密集的时候，就是投资者买进时机


分时图中的背离：可以通过红白线的乖离情况结合MACD线的情况很容易识别出来
（股价快速拉升，但是黄线（当日成交均线）不能快速跟随白线（即时股价），一般情况都是背离的表现，
   同时，如果股价创出新高，但MACD线不能创出新高，则是背离情况的验证）

洗筹：上洗套牢，下洗跟风(获利)，形成单峰密集
定格筹码：股票最大的单峰
底背离：量平价跌




十大股东流通盘多少 65%
少于65%，不需要修改
大于65%：1 /（1 - 65%）



业务流程、经营方式

现金流量表(主营业务收入: 主营业务收入占比越高，长期投资价值越大)
 分：
   经营活动现金流：经营活动现金流净额
   投资活动现金流
   筹资活动现金流：期末现金及现金等价物
 

战法1：
（黄色线vol设置，3,3，只有一根线）
成交量没有站上黄色线，认为是没有主力在操作（不计算吸筹的累计值），
底部筹码图形松动，认为主力出货开始
出货累计 > 吸筹累计，开始下跌

zt

战法2：
开始吸筹时的 筹码集中度xx
出货至少要 xx*2
主力吸筹，集中度变小
主力出货，集中度变大


表单使用 application/x-www-form-urlencoded 时，需要对参数进行 URLEncode 编码和序列化
multipart/form-data 消息体，包含多个块组成，每个块代表一个有效的表单控件，并使用 boundary 的字符串分割

form-data与x-www-form-urlencoded的区别：
	multipart/form-data：可以上传文件或者键值对，最后都会转化为一条消息
	x-www-form-urlencoded：只能上传键值对，而且键值对都是通过&间隔分开的

JavaScript 和 TypeScript 的静态类型交叉口 —— 类型定义文件d.ts

类型别名
接口interface 和 类型别名type的对比：
   相同点：都可以给对象指定类型
   不同点：
	接口只能为对象指定类型；类型别名可以为任意类型（包括函数）指定别名
   先有的 interface，后有的 type,推荐使用 type

枚举也分数值枚举 和 字符串枚举

any
unknow(ts3.0)
void： 声明一个 void 类型的变量没有什么作用，因为它的值只能为 undefined 或 null
Null 和 Undefined 类型： null 和 undefined 是所有类型的子类型

交叉类型： type IStaff = IPerson & IWorker
接口Interface：1，对类进行抽象； 2，对对象的形状进行描述

只读属性： readonly， ReadonlyArray

在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 
这样用户就可以以自己的数据类型来使用组件。

泛型（Generics）是允许同一个函数接受不同类型参数的一种模板
       设计泛型的关键目的是在成员之间提供有意义的约束
 


permission :: GenerateRoutes 获取动态路由


DeFi：
数浪技术、缠论

然而，没有任何一个领域像金融领域一样，把握过去就是成功的根本
无论如何我都要保持开放、宽容的心态，否则我没有办法迎接接下来我们会再次碰到的新颠覆、新创新和新发明

目前在加密领域有哪些值得研究和关注的领域呢？大体上有这些：底层公链、第二层扩展技术、DeFi、NFT、游戏等



D:\broadcast\直播\苹果\语音直播iOS\yyzb\Library\LibOther\klcAssets.xcassets
D:\broadcast\broadcast1\src\assets\images\klcAssets.xcassets

什么是 HLS 呢？HLS 主要的两块内容是 .m3u8 文件 和  .ts 播放文件
一个提供 HLS 的服务器需要做两件事：
编码：以 H.263 格式对图像进行编码，以 MP3 或者 HE-AAC 对声音进行编码，
         最终打包到 MPEG-2 TS（Transport Stream）容器之中
分割：把编码好的 TS 文件等长切分成后缀为 ts 的小文件，并生成一个 .m3u8 的纯文本索引文件；

整个直播过程就是依靠一个不断更新的 m3u8 和一堆小的 ts 文件组成，m3u8 必须动态更新，ts 可以走 CDN


区块链概念：
权益证明运作：综合考量多种因素，包括质押年龄（一个随机化元素）和节点财富 等
Go Ethereum (Geth）实现了Ethereum 协议(黄皮书)中所有需要的实现的功能模块，
	包括状态管理，挖矿，P2P 网络通信，密码学，数据库，EVM 解释器等

EVM 解释器：solidity虚拟机，EVM 不是基于寄存器的，而是基于栈的

ETH2.0: 权益证明、分片链、信标链
  分片链只含有一条完整区块链的特定子集；信标链提供共识，确保所有分片链并行运作；

  ERC20标准无法通过接收方合同处理传入的交易。这是该令牌存在的最大问题
  基于ERC-20标准发行的Token没有价值区别，可以互换，可以分割  -- USDT, USDC
  基于ERC-721标准发行的Token不可互换，每个Token都是独一无二的，且是不可以分割的  -- NTF
  基于ERC-1155标准发行半同质化代币
 
代币的可替代程度由以太坊上的三个代币标准之一来表示 – ERC20、ERC721 和 ERC1155

Chainlink是一个基于区块链的去中心化预言机网络，它让智能合约能够关联至外部数据源
   LINK是一种ERC-20代币，用于支付网络上的Chainlink预言机服务

Uniswap是构建于以太坊的去中心化交易平台协议 -- 自动化的流动性协议

Polygon：
   Polygon框架支持两类与以太坊相兼容的主要网络：安全链和独立链。举例来说，“汇总”(Rollup)是一种安全链，侧链则属于独立链
   与eth主网并行运行但在主网之外处理交易的区块链，从而提高了交易吞吐量和更便宜的gas

以太坊合并不会降低以太坊的gas费用或提高以太坊的速度，仅仅是环保？？


第二层？
Arbitrum、Optimism、
并行链（侧链）？
(Avalanche、Fantom)

  侧链基于以太坊虚拟机（EVM），它是以太坊的计算引擎，基于自身链安全，基于自身链协议，为并行链
  第 2 层协议是存在于以太坊链中的链，但能够通过辅助框架实现更大的可扩展性（继承以太坊主链的安全，为主链的子链）
  第 2 层扩展解决方案包括通道、汇总和等离子
  币安职能类，火币链则是以太坊的硬分叉，兼容以太坊虚拟机

 以太坊 2.0 有自己的侧链变体，称为分片链，它们连接到最近推出的信标链，旨在最终成为基于权益证明 (PoS) 的以太坊的主链


大众协作、充分去中心化的基因
从零开始、众生平等、社区推动这三大要素


Curve是目前DeFi生态中稳定币最大的交易平台

拓展eth的扩展性： Layer2、 分片(已升级到eth2.0中）

plasma??
Plasma 主张在链下执行交易，在主网上进行结算，并使用欺诈证明来仲裁争议。采用该方案的项目有 OMG 网络、Polygon
状态通道??
状态通道主张只提交第一笔和最后一笔交易到主网，其他交易在链下处理后提交证明给主网。类似于比特币常用的闪电网络。采用该方案的项目有 Celer Network、Raiden Network










<script>
    var language = window.navigator.language
    var lang = /vi/ig.test(language)?'vi':'en'   
    if(lang == 'en'){
        document.querySelector('#englishVersion').style.display = 'block'
        document.body.removeChild(document.querySelector('#viVersion'))
    } else {
        document.querySelector('#viVersion').style.display = 'block'
        document.body.removeChild(document.querySelector('#englishVersion'))
    }
</script>


Solidity：
  关键字 public 自动生成一个getter函数，允许你在这个合约之外访问这个状态变量的当前值

  创建合约的人的地址: msg， 是一个全局变量；msg.sender 始终是当前（外部）函数调用的来源地址
  合约的地址：是通过合约创建者的地址和从该地址发出过的交易数量计算得到的（所谓的“nonce”）
   ****所有合约都继承了地址（address）的成员变量


  所有的指令都是针对"256位的字（word）"这个基本的数据类型来进行操作
  
  函数修饰器：以声明的方式改良函数语义； gas 或者 value 修饰器
  地址address成员变量：balance， transfer,   send
	（send 是 transfer 的低级版本。如果执行失败，当前的合约不会因为异常而终止，但 send 会返回 false）

  二进制接口Application Binary Interface(ABI) 的合约

call与delegatecall：
	delegatecall只使用给定地址的代码，其它属性（存储，余额，……）都取自当前合约



定长字节数组：bytesX
变长字节数组：bytes,  string（不是值类型）

address：
	1，通过地址校验和测试（如没有通过校验视为有理数字常数）；  
	2，十六进制字面常数，长度在39到41位（Solidity 中是没有八进制）
函数：
  1，function (<parameter types>) {internal|external} [pure|constant|view|payable] [returns (<return types>)]
  2，合约中的函数本身默认是 public 的，只有当它被当做类型名称时，默认才是内部函数
  3，public（或 external）函数可通过this调用，也有一个特殊的成员变量称作 selector，可以返回 ABI 函数选择器

复杂类型，即 数组 和 结构 类型，
  1，都有一个额外属性“数据位置”，说明数据是保存在 内存memory 中还是 存储storage 中
  2，数据位置可以通过在类型名后增加关键字 storage 或 memory 进行修改
  3，函数参数（包括返回的参数）的数据位置默认是 memory， 局部变量的数据位置默认是 storage，
       状态变量的数据位置强制是 storage
  4，calldata用来存储函数参数，是只读的，且不会永久存储的位置，外部函数的参数（非返回参数）的数据位置被强制指定为        calldata


数组：
  1， bytes 和 string 类型的变量是特殊的数组，不允许用长度或索引来访问，只能：bytes(string).length || bytes(string)[7] = 'x'
  2,   动态数组可以在 存储storage （而不是 内存memory ）中通过改变成员变量 .length 改变数组大小
  3,  一经创建，内存memory 数组的大小就是固定的 (因为已经在内存中分配了连续的存储空间)

映射类型：  mapping(_KeyType => _ValueType)
  1， 在映射中，实际上并不存储 key，而是存储它的 keccak256 哈希值

LValues 的运算符：
  1， delete xxx(各含义）；  2， delete 对整个映射是无效的

类型推断（var声明）：编译器会根据分配该变量的第一个表达式的类型自动推断该变量的类型


ABI 编码函数：

address调用所有的属性函数都会消耗gas，其中transfer和send消耗2300gas，且gas值不可调节


合约：
  函数默认位public， 状态变量默认为internal（）
  
  external与public区别？？
     external仅可用于消息调用（即使在合约内调用，也只能通过 this.func 的方式）；public可以在内部或通过消息调用
  internal与private
      internal可在当前合约和子合约访问；private只能在当前合约访问

  编译器自动为所有 public 状态变量创建 同名 getter 函数

修饰器：
    修饰器modifier 是合约的可继承属性， 并可能被派生合约覆盖
    从0.4.0开始 修饰器modifier 或函数体中显式的 return 语句仅仅跳出当前的 修饰器modifier 和函数体，执行逻辑会从
         前一个 修饰器modifier 中     的定义的 “_” 之后继续执行；  
    `_;` 会被实际使用这个修饰器的函数体所替代


  关键字 `payable` 非常重要，否则函数会自动拒绝所有发送给它的以太币


函数：
  view函数：函数声明为 view 类型，这种情况下要保证不修改状态；constant 是 view 的别名
      Getter 方法被标记为 view
  Pure 函数：承诺不读取或修改状态
  Fallback 函数：
       为anonymous的public函数 
       函数不能有参数也不能有返回值；
       每当合约收到以太币（没有任何数据），fallback函数就会执行；
       为了接收以太币，fallback 函数必须标记为 payable；
       如果想让合约接收以太币，必须实现 fallback 函数

事件：
    1，事件通过watch 或 回调函数 监听变化
    1，事件在合约中可被继承
    2，日志和事件在合约内不可直接被访问（甚至是创建日志的合约也不能访问）


继承：
     1，如果一个合约没有实现所有函数，则只能用作接口
     2，所有的函数调用都是虚拟的，这意味着最远的派生函数会被调用，除非明确给出合约名称
     3，基类合约构造函数调用：
   	1，在继承列表中调用基类构造函数
	2，像 修饰器modifier 使用方法一样， 作为派生合约构造函数定义头的一部分
     3，继承规则：从“最接近的基类”到“最远的继承”的顺序来指定所有的基类
	          继承时 状态变量的 getter 可以覆盖一个 public 函数





抽象合约：抽象合约无法编译，只能用于基类合约
接口：       接口不能实现任何函数，接口不能继承合约或接口


库：
    1，库可以看作是使用他们的合约的隐式的基类合约；因此所有使用库的合约，库的 internal 函数都是可见的
    2，库函数被调用，它的代码在调用合约的上下文中执行，即 this 指向调用合约
    3，如果库的代码是通过 CALL 来执行，而不是 DELEGATECALL 或者 CALLCODE 那么执行的结果会被回退， 
	除非是对 view 或者 pure 函数的调用
    4，库的运行时代码总是从一个 push 指令开始

using  for ???
  指令 using A for B; 可用于附加库函数（从库 A）到任何类型（B）




内存变量，会将地址而不是值压入栈中
存储变量地址由存储槽和槽内的字节偏移量组成
可以给汇编局部变量和函数局部变量赋值。当给指向内存或存储的变量赋值时，你只是更改指针而不是数据。


基本类型仅使用存储它们所需的字节；
结构（struct）和数组数据总是会占用一整个新插槽







require？？？：如果条件值为 false 则中止执行并回退所有状态变更（用做异常输入或外部组件错误）

 内联汇编是一种在底层访问以太坊虚拟机的语言。这抛弃了很多 Solidity 提供的重要安全特性
  内联汇编程序由 assembly { ... } 来标记
   mem[a...b) 表示从位置 a 开始至（不包括）位置 b 的内存字节数



安全陷阱：
   1，随机数，最好使用链外Oraclize服务获取
   2，从合约 A 到合约 B 的交互以及任何从合约 A 到合约 B 的 以太币Ether 的转移，都会将控制权交给合约 B。 
         这使得合约 B 能够在交互结束前回调 A 中的代码    —--use--—>   检查-生效-交互
   3，谨慎使用没有固定迭代次数的循环（可能gas用光，执行就此打住）
   4，确保你的合约可以通过这种方式收到 以太币Ether，请核对 fallback 函数所需的 gas 数量 
   5，addr.call.value(x)() 会发送所有剩下的gas
   6，如果调用的深度超过 1024，发送 以太币Ether 也会失败
   7，发送 以太币Ether 也可能因为接收方合约的执行所需的 gas 多于分配的 gas 数量而失败 -->  
	用“取回”模式而不是“发送”模式
   8，永远不要使用 tx.origin 做身份认证

故障-安全（Fail-Safe）模式：函数最开始 实现某种程度上的自检查


函数调用数据的前 4 字节，指定了要调用的函数，从第5字节开始是被编码的参数
ABI 元组tuple 是利用 Solidity 的 structs 编码得到的

动态类型：bytes， string,  T[],   T[k],   (T1, ..., Tk)
len(a) 是一个二进制字符串 a 的字节长度


Event:
    事件在solidity中声明，触发，由前端进行监听
    indexed：如果此事件字段是日志的一个主题，则为 true；否则为 false



代码书写格式：
   1， 应该严格地标示所有函数的可见性，包括构造函数
   2， 函数的可见性修饰符应该出现在任何自定义修饰符之前




想让合约不再可用，建议的做法是修改合约内部状态来使其 失效



1,  string[] memory myarray = ["a", "b"]; 方式 只能用于定长 内存memory 数组，即
        数组in-line方式初始化时，只能为 静态的内存 数组
2,  合约的函数可以返回结构 struct ：只适用于内部internal函数调用
3,  uint 和 int 分别是 uint256 和 int256 的别名
     byte 是 bytes1 的别名
     函数类型默认是内部函数，因此不需要声明 internal 关键字
     合约中的函数本身默认是 public 的，只有当它被当做类型名称时，默认才是内部函数

     函数参数（包括返回的参数）的数据位置默认是 memory， 
     局部变量的数据位置默认是 storage，状态变量的数据位置强制是 storage

     映射中，实际上并不存储 key，而是存储key的 keccak256 哈希值
     想修改一个字符串（甚至你只是想获取其长度），首先都必须将其转化为一个 bytes

     ****  存储storage 不是动态分配的 
 	uint[] data -->  编译器将 data 解析为一个 存储storage 指针，并默认将指针指向 存储插槽storage slot 0

   “创建”数组纯粹是免费的，成本在于填充数组

     如何初始化一份只包含指定数量 wei 的合约??

   假设 bytes 储存的是字符串的 UTF-8 编码，那么它和 string 基本是等同的

   storage参数XXX传递时如果认为是memory位置的，会在 内存memory 中对 存储storage 的值创建一份独立的拷贝

   memory数组已分配好联系存储空间，因此length不可更改，storage数组可以
   在 Solidity 中，数组维数的声明方向是和在 C 或 Java 中的声明方向相反的，但访问方式相同

   构造函数做的最后一件事情是返回合约的代码。这件事消耗的 gas 取决于代码的长度



V0.8.16：
  error：
     1，提供了一种方便且省gas的方式解释为什么一个操作会失败
     2，error不能被重写或覆盖，但是可以继承，revert操作传递给调用者，在 try/catch 中捕获 
     3，require(condition, "description")  与  if (!condition) revert Error("description") 等效

  constant 常量的值在编译器确定，而 immutable的值在部署时确定
     1, 常量和不可变量的gas成本要低得多；constant, immutable当前仅支持字符串 和 值类型
     2, immutable不可变量可以在声明时赋值，不过只有在合约的构造函数执行时才被视为视为初始化
         immutable >= 0.6.5版本

   继承：
      子类合约状态变量覆盖父类状态变量被视为错误
      虚拟合约增加abstract 关键字标识 

      覆盖函数，则需要使用 `override` 关键字。 如果您想再次覆盖此函数，则需要再次指定`virtual`关键字
      重写函数只能将覆盖函数的可见性从 external 更改为 public
      函数重写时:   nonpayable 可以被 view 和 pure 覆盖。 
	          view 可以被 pure 覆盖
	          payable 是一个例外，不能更改为任何其他可变性
      多重继承，override 关键字后必须指定所有父合约名
      如果函数没有标记为 virtual ， 那么派生合约将不能更改函数的行为（即不能重写）
      修饰器重写方式与函数重写类似，被重写的修改器也需要 virtual 修饰， override 则同样修饰重载
      代码的部署需要 gas 与代码的长度线性相关

     可使用 new 关键字在 内存memory 中基于运行时创建动态长度数组。 与 存储storage 数组相反的是，
	你 不能 通过修改成员变量 .push 改变 内存memory 数组的大小





web3.js：
   web.eth所有函数默认使用同步的HTTP请求；可以传一个跟在参数列表后的可选的回调函数来支持异步请求
   如果要修改区块链上的数据，一定要使用sendTransaction，这会消耗gas
   如果不修改区块链上的数据，使用call，这样不会消耗gas




blockhash?? 自定义函数还是？



?_uid_=10001&_token_=606acdfffaad458a8836b62be9d64c1d&type=1&locale=en


"vue": "^2.5.2",
    "vue-i18n": "^8.7.0",
    "vue-resize-text": "^0.1.1",
    "vue-router": "^3.0.1",


NFT: 技术创造、社群、公共关系（项目运营）
    在加密世界里有故事背景，有主角设定和娱乐活动，还有自己的土地和货币
    很多品牌都看上了无聊猿的  营销和传播价值
    团队打造了自己的商业变现模式
    Yuga Labs 打造了基于 NFT 流通性的 IP 商业模式
    无聊猿更像是一个搭载区块链技术，在 NFT 应用场景下的 IP 生意
    愿景：Web3 生活方式的公司

Yuga Labs的热度依赖于NFT实用性、空投福利和社区活动











本轮加密市场熊市低谷的猜测分析（2022-07-14 17:08）：11月到来年2月底，再来一次黑天鹅事件？？
熊市会持续多久？如何布局下一轮牛市？ ：  比特币在15000美元和25000美元之间徘徊、以太坊在1000美元到1500美元之间徘徊；
或者更低一点比特币在20000美元以下徘徊、以太坊在1200美元以下徘徊；
一旦加密生态再暴雷，情况会更糟，比特币跌到10000美元以下，以太坊跌到800美元以下；



目前市面上最常用的稳定币有三种：USDT、DAI和USDC。我自己只会持有DAI和USDC，从2019年以来我就是如此。








task：
1，彩票
2，直播
3，搭建跨墙云服务
4，学习
     1，git
     2，前沿
D:\2345Downloads\对接部分后台页面参考

学习：
   加密领域认知提升；  solidity，web3.js技术学习；  








git remote set-url origin http://114.119.174.143:9980/gitlab-instance-da17327d/zbgyy.git







